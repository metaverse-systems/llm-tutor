import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { buildThemeCollections, themeTokens, type ThemeToken } from "./tokens.js";

export interface GenerateThemeCssOptions {
  tokens?: readonly ThemeToken[];
  includeHeader?: boolean;
}

export interface GenerateThemeJsonOptions {
  tokens?: readonly ThemeToken[];
  pretty?: boolean;
}

export interface WriteThemeAssetsOptions {
  tokens?: readonly ThemeToken[];
  outDir?: string;
  cssFilename?: string;
  jsonFilename?: string;
  prettyJson?: boolean;
}

interface CssVariable {
  name: string;
  value: string;
}

type ThemeVariant = "standard" | "contrast";

interface ThemeAssetJson {
  version: number;
  generatedAt: string;
  tokens: readonly ThemeToken[];
}

const HEADER = `/**
 * DO NOT EDIT DIRECTLY
 * Generated by packages/shared/src/styles/generateThemeAssets.ts
 */`;

function formatValue(token: ThemeToken, variant: ThemeVariant): CssVariable[] {
  const value = variant === "standard" ? token.value : token.contrast.high;
  switch (value.type) {
    case "color":
      return [{ name: token.id, value: value.hex }];
    case "spacing":
      return [{ name: token.id, value: `${value.rem}rem` }];
    case "radius":
      return [{ name: token.id, value: `${value.rem}rem` }];
    case "shadow":
      return [{ name: token.id, value: value.value }];
    case "motion":
      return [
        { name: `${token.id}-duration`, value: `${value.durationMs}ms` },
        { name: `${token.id}-easing`, value: value.easing }
      ];
    case "typography":
      return [
        { name: `${token.id}-font-family`, value: value.fontFamily },
        { name: `${token.id}-font-size`, value: value.fontSize },
        { name: `${token.id}-line-height`, value: value.lineHeight },
        ...(value.fontWeight ? [{ name: `${token.id}-font-weight`, value: `${value.fontWeight}` }] : [])
      ];
    case "opacity":
      return [{ name: token.id, value: `${value.value}` }];
    default:
      return [];
  }
}

function buildVariableSection(tokens: readonly ThemeToken[], variant: ThemeVariant): string {
  const sorted = [...tokens].sort((a, b) => a.id.localeCompare(b.id));
  const variables = sorted.flatMap((token) => formatValue(token, variant));
  const lines = variables.map((variable) => `  --${variable.name}: ${variable.value};`);
  if (lines.length === 0) {
    return "";
  }
  if (variant === "standard") {
    return `:root {\n${lines.join("\n")}\n}`;
  }
  return `[data-theme="contrast"] {\n${lines.join("\n")}\n}`;
}

export function generateThemeCss(options: GenerateThemeCssOptions = {}): string {
  const tokens = options.tokens ?? themeTokens;
  const sections = [buildVariableSection(tokens, "standard"), buildVariableSection(tokens, "contrast")].filter(
    (section) => section.trim().length > 0
  );
  const body = sections.join("\n\n");
  return options.includeHeader === false ? `${body}\n` : `${HEADER}\n${body}\n`;
}

export function generateThemeJson(options: GenerateThemeJsonOptions = {}): string {
  const tokens = options.tokens ?? themeTokens;
  const payload: ThemeAssetJson = {
    version: 1,
    generatedAt: new Date().toISOString(),
    tokens
  };
  const pretty = options.pretty ?? true;
  return JSON.stringify(payload, null, pretty ? 2 : undefined) + "\n";
}

function resolveOutDir(outDir?: string): string {
  if (outDir) {
    return outDir;
  }
  return fileURLToPath(new URL("../", import.meta.url));
}

export async function writeThemeAssets(options: WriteThemeAssetsOptions = {}): Promise<{ cssPath: string; jsonPath: string }> {
  const tokens = options.tokens ?? themeTokens;
  const outDir = resolveOutDir(options.outDir);
  const cssFilename = options.cssFilename ?? "theme.css";
  const jsonFilename = options.jsonFilename ?? "theme.tokens.json";
  await mkdir(outDir, { recursive: true });
  const cssPath = path.join(outDir, cssFilename);
  const jsonPath = path.join(outDir, jsonFilename);
  const css = generateThemeCss({ tokens });
  const json = generateThemeJson({ tokens, pretty: options.prettyJson });
  await Promise.all([writeFile(cssPath, css, "utf-8"), writeFile(jsonPath, json, "utf-8")]);
  return { cssPath, jsonPath };
}

export function buildTailwindTheme(tokens: readonly ThemeToken[] = themeTokens) {
  const collections = buildThemeCollections(tokens);
  const colors = {
    surface: Object.fromEntries(
      Object.entries(collections.colors.surface).map(([key, token]) => [key, `var(--${token.id})`])
    ),
    text: Object.fromEntries(
      Object.entries(collections.colors.text).map(([key, token]) => [key, `var(--${token.id})`])
    ),
    border: Object.fromEntries(
      Object.entries(collections.colors.border).map(([key, token]) => [key, `var(--${token.id})`])
    ),
    accent: Object.fromEntries(
      Object.entries(collections.colors.accent).map(([key, token]) => [key, `var(--${token.id})`])
    ),
    state: Object.fromEntries(
      Object.entries(collections.colors.state).map(([key, token]) => [key, `var(--${token.id})`])
    )
  } as const;

  const spacing = Object.fromEntries(
    Object.entries(collections.spacing).map(([key, token]) => [`spacing-${key}`, `var(--${token.id})`])
  );

  const borderRadius = Object.fromEntries(
    Object.entries(collections.radius).map(([key, token]) => [`radius-${key}`, `var(--${token.id})`])
  );

  const fontFamilyEntries = Object.entries(collections.typography).map(
    ([key, token]) => [key, `var(--${token.id}-font-family)`] as const
  );
  const fontFamily = Object.fromEntries(fontFamilyEntries) as Record<string, string>;

  const fontSizeEntries = Object.entries(collections.typography).map(
    ([key, token]) =>
      [
        key,
        [
          `var(--${token.id}-font-size)`,
          {
            lineHeight: `var(--${token.id}-line-height)`
          }
        ]
      ] as const
  );
  const fontSize = Object.fromEntries(fontSizeEntries) as Record<string, [string, { lineHeight: string }]>;

  const boxShadow = Object.fromEntries(
    Object.entries(collections.shadows).map(([key, token]) => [key, `var(--${token.id})`])
  );

  const transitionDuration = Object.fromEntries(
    Object.entries(collections.motion).map(([key, token]) => [key, `var(--${token.id}-duration)`])
  );

  const transitionTimingFunction = Object.fromEntries(
    Object.entries(collections.motion).map(([key, token]) => [key, `var(--${token.id}-easing)`])
  );

  return {
    colors,
    spacing,
    borderRadius,
    fontFamily,
    fontSize,
    boxShadow,
    transitionDuration,
    transitionTimingFunction
  };
}

async function runCli(): Promise<void> {
  const result = await writeThemeAssets();
  console.log(`Theme assets written to ${result.cssPath} and ${result.jsonPath}`);
}

if (import.meta.url === (process.argv[1] ? pathToFileUrl(process.argv[1]).href : "")) {
  void runCli().catch((error) => {
    console.error("Failed to build theme assets", error);
    process.exitCode = 1;
  });
}

function pathToFileUrl(filePath: string): URL {
  return new URL(`file://${path.resolve(filePath)}`);
}
